---
import type { Lang } from '@/i18n';

interface Props {
  lang: Lang;
}

const { lang } = Astro.props;

const greetings = {
  en: ["Welcome to the Lab!", "Experiments are brewing..."],
  it: ["Benvenuto nel Lab!", "Gli esperimenti stanno prendendo forma..."]
};
---

<canvas id="particle-canvas" data-greetings={JSON.stringify(greetings[lang])}></canvas>

<script>
  const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  // Get greetings from data attribute
  let greetings: string[] = JSON.parse(canvas.dataset.greetings || '["Welcome!"]');
  let currentGreetingIndex = 0;

  // Mobile detection
  const isMobile = (window.innerWidth || 800) <= 768;

  // Adaptive settings
  const particleCount = isMobile ? 2000 : 6000;
  const maxDistance = isMobile ? 80 : 100;

  function resizeCanvas() {
    canvas.width = window.innerWidth || 800;
    canvas.height = window.innerHeight || 600;
  }

  resizeCanvas();

  // Responsive font size
  function getFontSize() {
    const width = window.innerWidth || 800;
    const baseSize = Math.min(width / 12, 80);
    return Math.max(baseSize, 24);
  }

  let fontSize = getFontSize();
  ctx.font = `bold ${fontSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  interface ParticleType {
    x: number;
    y: number;
    size: number;
    baseX: number;
    baseY: number;
    density: number;
    draw: () => void;
    update: () => void;
  }

  const particles: ParticleType[] = [];

  const mouse = {
    x: null as number | null,
    y: null as number | null
  };

  function createParticle(x: number, y: number): ParticleType {
    return {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: 2,
      baseX: x,
      baseY: y,
      density: (Math.random() * 30) + 1,
      draw() {
        ctx.fillStyle = '#272727';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
      },
      update() {
        if (mouse.x === null || mouse.y === null) {
          // Return to base position
          if (this.x !== this.baseX) {
            const dx = this.x - this.baseX;
            this.x -= dx / 10;
          }
          if (this.y !== this.baseY) {
            const dy = this.y - this.baseY;
            this.y -= dy / 10;
          }
          return;
        }

        const dx = mouse.x - this.x;
        const dy = mouse.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < maxDistance) {
          const forceDirectionX = dx / distance;
          const forceDirectionY = dy / distance;
          const force = (maxDistance - distance) / maxDistance;
          const directionX = forceDirectionX * force * this.density;
          const directionY = forceDirectionY * force * this.density;

          this.x -= directionX;
          this.y -= directionY;
        } else {
          if (this.x !== this.baseX) {
            const dx = this.x - this.baseX;
            this.x -= dx / 10;
          }
          if (this.y !== this.baseY) {
            const dy = this.y - this.baseY;
            this.y -= dy / 10;
          }
        }
      }
    };
  }

  function getTextY() {
    return canvas.height * 0.4;
  }

  function drawGreeting(text: string) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#d2b48c';
    ctx.fillText(text, canvas.width / 2, getTextY());
  }

  function init() {
    particles.length = 0;

    if (canvas.width === 0 || canvas.height === 0) {
      resizeCanvas();
    }

    fontSize = getFontSize();
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    drawGreeting(greetings[currentGreetingIndex]);
    const textCoordinates = ctx.getImageData(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < particleCount; i++) {
      let x: number, y: number;
      let attempts = 0;
      const maxAttempts = 10000;

      do {
        x = Math.floor(Math.random() * canvas.width);
        y = Math.floor(Math.random() * canvas.height);
        attempts++;
      } while (
        textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] <= 128 &&
        attempts < maxAttempts
      );

      if (attempts < maxAttempts) {
        particles.push(createParticle(x, y));
      }
    }
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const particle of particles) {
      particle.draw();
      particle.update();
    }
    requestAnimationFrame(animate);
  }

  // Touch handling
  let touchStartTime: number | null = null;
  let touchTimeout: ReturnType<typeof setTimeout> | null = null;
  const TAP_DURATION = 300;
  const ANIMATION_DURATION = 300;

  // Mouse events
  window.addEventListener('mousemove', (event) => {
    if (!isMobile) {
      mouse.x = event.x;
      mouse.y = event.y;
    }
  });

  // Touch events
  window.addEventListener('touchstart', (event) => {
    if (event.touches.length > 0) {
      mouse.x = event.touches[0].clientX;
      mouse.y = event.touches[0].clientY;
      touchStartTime = Date.now();

      touchTimeout = setTimeout(() => {
        touchStartTime = null;
      }, TAP_DURATION);
    }
  }, { passive: true });

  window.addEventListener('touchmove', (event) => {
    if (event.touches.length > 0) {
      mouse.x = event.touches[0].clientX;
      mouse.y = event.touches[0].clientY;
    }
  }, { passive: true });

  window.addEventListener('touchend', () => {
    if (touchTimeout) {
      clearTimeout(touchTimeout);
      touchTimeout = null;
    }

    if (touchStartTime && (Date.now() - touchStartTime < TAP_DURATION)) {
      setTimeout(() => {
        mouse.x = null;
        mouse.y = null;
      }, ANIMATION_DURATION);
    } else {
      mouse.x = null;
      mouse.y = null;
    }
    touchStartTime = null;
  });

  // Resize handler
  window.addEventListener('resize', () => {
    resizeCanvas();
    init();
  });

  // Change greeting every 5 seconds
  setInterval(() => {
    currentGreetingIndex = (currentGreetingIndex + 1) % greetings.length;
    drawGreeting(greetings[currentGreetingIndex]);
    const textCoordinates = ctx.getImageData(0, 0, canvas.width, canvas.height);

    for (const particle of particles) {
      let x: number, y: number;
      let attempts = 0;
      const maxAttempts = 10000;

      do {
        x = Math.floor(Math.random() * canvas.width);
        y = Math.floor(Math.random() * canvas.height);
        attempts++;
      } while (
        textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] <= 128 &&
        attempts < maxAttempts
      );

      if (attempts < maxAttempts) {
        particle.baseX = x;
        particle.baseY = y;
      }
    }
  }, 5000);

  // Initialize
  init();
  animate();
</script>

<style>
  #particle-canvas {
    position: absolute;
    top: 0;
    left: 0;
    margin: 0;
    z-index: -1;
  }
</style>
